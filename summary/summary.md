# 1. 数组

## 1.1 排序

- Leetcode 217: 给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。
  > 排序：O(nlogn)+O(1)；哈希：O(n)+O(n)

- Leetcode 219: 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。
  > 维护大小为k的搜索树：O(nlogk)+O(k)；哈希：O(n)+O(k)

- Leetcode 220: 给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。
  > 维护大小为k的搜索树：O(nlogk)+O(k)；以t做分桶：O(n)+O(k)

- Leetcode 287: （鸽子洞原理、抽屉原理）给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
  > 排序：O(nlogn)+O(1)；哈希：O(n)+O(n)；
  > 各元素归位：O(n)+O(1)；当数组不能被修改时，使用二分：O(nlogn)+O(1)；循环检测（转换为带环链表查环节点）：O(n)+O(1)

## 2.2 查找

- Leetcode 153: 旋转排序数组找最小值（无重复元素）
  > 以数组第一个元素为判断锚点，二分查找

- Leetcode 33: 旋转排序数组找某个值（无重复元素）
  > 先找旋转轴点再二分；或者直接二分找

- Leetcode 81: 旋转排序数组找某个值（有重复元素）
  > 退化为顺序查找？；左边界缩减？

## 2. 字符串

- 将字符串中的空格替换为%20
  > O(n)+O(1)
  > 归并排序合并两个数组的思想

## 3. 链表

- 从尾到头打印链表
  > 栈：O(n)+O(n)；翻转链表：O(n)+O(1)

## 4. 树

- Leetcode 105: 前序和中序重建二叉树

- Leetcode 106: 后序和中序重建二叉树

- Leetcode 889: 前序和后序重建二叉树，任意符合的都可以
  > 为什么前序和后序不能唯一确定一棵树？

## 5. 栈/队列

- Leetcode 232: 栈实现队列

- Leetcode 225: 队列实现栈

## 6. dp

- Leetcode 240: 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。
  > dp：O(m+n)+O(1)；如果条件更严格直接可转换为一维排序数组，则二分：O(log(m+n))+O(1)

- Leetcode 70: 跳台阶

- 如果跳台阶每次可以跳1~n阶呢？

- Leetcode 746: 每跳到一个台阶花费对应的cost，问cost最小的跳法

- 矩阵覆盖: 用2×1的矩形覆盖2×n的矩形，问有覆盖几种方法

